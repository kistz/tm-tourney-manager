// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

// This was generated using spacetimedb cli version 1.5.0 (commit 0712d3bfbd159367de09efeeeacb54c9d4f0ff61).

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{self as __sdk, __lib, __sats, __ws};

pub mod add_event_reducer;
pub mod add_server_reducer;
pub mod add_stage_reducer;
pub mod assign_server_reducer;
pub mod call_server_reducer;
pub mod client_connected_reducer;
pub mod common_type;
pub mod create_event_template_reducer;
pub mod create_tournament_reducer;
pub mod custom_type;
pub mod end_map_end_type;
pub mod end_map_start_type;
pub mod end_round_end_type;
pub mod end_round_start_type;
pub mod event_config_table;
pub mod event_config_type;
pub mod event_phase_type;
pub mod event_stage_table;
pub mod event_stage_type;
pub mod event_type;
pub mod give_up_type;
pub mod identity_disconnected_reducer;
pub mod load_server_config_reducer;
pub mod loading_map_end_type;
pub mod loading_map_start_type;
pub mod map_type;
pub mod match_status_type;
pub mod match_template_table;
pub mod match_template_type;
pub mod method_type;
pub mod mode_config_type;
pub mod on_tournament_event_schedule_reducer;
pub mod play_loop_end_type;
pub mod play_loop_start_type;
pub mod player_chat_type;
pub mod player_connect_type;
pub mod player_disconnect_type;
pub mod player_type;
pub mod podium_type;
pub mod post_event_reducer;
pub mod provision_match_reducer;
pub mod respawn_bavaviour_type;
pub mod respawn_type;
pub mod round_time_type;
pub mod rounds_type;
pub mod scores_type;
pub mod server_config_type;
pub mod stage_match_table;
pub mod stage_match_type;
pub mod stage_template_table;
pub mod stage_template_type;
pub mod start_line_type;
pub mod start_map_type;
pub mod start_turn_type;
pub mod team_type;
pub mod tm_server_config_table;
pub mod tm_server_config_type;
pub mod tm_server_event_table;
pub mod tm_server_event_type;
pub mod tm_server_table;
pub mod tm_server_type;
pub mod tournament_event_schedule_table;
pub mod tournament_event_schedule_type;
pub mod tournament_event_table;
pub mod tournament_event_type;
pub mod tournament_status_type;
pub mod tournament_table;
pub mod tournament_type;
pub mod try_start_reducer;
pub mod ubisoft_id_type;
pub mod unloading_map_end_type;
pub mod unloading_map_start_type;
pub mod user_table;
pub mod user_type;
pub mod warmup_duration_type;
pub mod way_point_type;

pub use add_event_reducer::{add_event, set_flags_for_add_event, AddEventCallbackId};
pub use add_server_reducer::{add_server, set_flags_for_add_server, AddServerCallbackId};
pub use add_stage_reducer::{add_stage, set_flags_for_add_stage, AddStageCallbackId};
pub use assign_server_reducer::{
    assign_server, set_flags_for_assign_server, AssignServerCallbackId,
};
pub use call_server_reducer::{call_server, set_flags_for_call_server, CallServerCallbackId};
pub use client_connected_reducer::{
    client_connected, set_flags_for_client_connected, ClientConnectedCallbackId,
};
pub use common_type::Common;
pub use create_event_template_reducer::{
    create_event_template, set_flags_for_create_event_template, CreateEventTemplateCallbackId,
};
pub use create_tournament_reducer::{
    create_tournament, set_flags_for_create_tournament, CreateTournamentCallbackId,
};
pub use custom_type::Custom;
pub use end_map_end_type::EndMapEnd;
pub use end_map_start_type::EndMapStart;
pub use end_round_end_type::EndRoundEnd;
pub use end_round_start_type::EndRoundStart;
pub use event_config_table::*;
pub use event_config_type::EventConfig;
pub use event_phase_type::EventPhase;
pub use event_stage_table::*;
pub use event_stage_type::EventStage;
pub use event_type::Event;
pub use give_up_type::GiveUp;
pub use identity_disconnected_reducer::{
    identity_disconnected, set_flags_for_identity_disconnected, IdentityDisconnectedCallbackId,
};
pub use load_server_config_reducer::{
    load_server_config, set_flags_for_load_server_config, LoadServerConfigCallbackId,
};
pub use loading_map_end_type::LoadingMapEnd;
pub use loading_map_start_type::LoadingMapStart;
pub use map_type::Map;
pub use match_status_type::MatchStatus;
pub use match_template_table::*;
pub use match_template_type::MatchTemplate;
pub use method_type::Method;
pub use mode_config_type::ModeConfig;
pub use on_tournament_event_schedule_reducer::{
    on_tournament_event_schedule, set_flags_for_on_tournament_event_schedule,
    OnTournamentEventScheduleCallbackId,
};
pub use play_loop_end_type::PlayLoopEnd;
pub use play_loop_start_type::PlayLoopStart;
pub use player_chat_type::PlayerChat;
pub use player_connect_type::PlayerConnect;
pub use player_disconnect_type::PlayerDisconnect;
pub use player_type::Player;
pub use podium_type::Podium;
pub use post_event_reducer::{post_event, set_flags_for_post_event, PostEventCallbackId};
pub use provision_match_reducer::{
    provision_match, set_flags_for_provision_match, ProvisionMatchCallbackId,
};
pub use respawn_bavaviour_type::RespawnBavaviour;
pub use respawn_type::Respawn;
pub use round_time_type::RoundTime;
pub use rounds_type::Rounds;
pub use scores_type::Scores;
pub use server_config_type::ServerConfig;
pub use stage_match_table::*;
pub use stage_match_type::StageMatch;
pub use stage_template_table::*;
pub use stage_template_type::StageTemplate;
pub use start_line_type::StartLine;
pub use start_map_type::StartMap;
pub use start_turn_type::StartTurn;
pub use team_type::Team;
pub use tm_server_config_table::*;
pub use tm_server_config_type::TmServerConfig;
pub use tm_server_event_table::*;
pub use tm_server_event_type::TmServerEvent;
pub use tm_server_table::*;
pub use tm_server_type::TmServer;
pub use tournament_event_schedule_table::*;
pub use tournament_event_schedule_type::TournamentEventSchedule;
pub use tournament_event_table::*;
pub use tournament_event_type::TournamentEvent;
pub use tournament_status_type::TournamentStatus;
pub use tournament_table::*;
pub use tournament_type::Tournament;
pub use try_start_reducer::{set_flags_for_try_start, try_start, TryStartCallbackId};
pub use ubisoft_id_type::UbisoftId;
pub use unloading_map_end_type::UnloadingMapEnd;
pub use unloading_map_start_type::UnloadingMapStart;
pub use user_table::*;
pub use user_type::User;
pub use warmup_duration_type::WarmupDuration;
pub use way_point_type::WayPoint;

#[derive(Clone, PartialEq, Debug)]

/// One of the reducers defined by this module.
///
/// Contained within a [`__sdk::ReducerEvent`] in [`EventContext`]s for reducer events
/// to indicate which reducer caused the event.

pub enum Reducer {
    AddEvent {
        name: String,
        at: __sdk::Timestamp,
        to: u64,
        with_config: Option<u64>,
    },
    AddServer {
        id: String,
    },
    AddStage {
        name: String,
        to: u64,
        with_config: Option<u64>,
    },
    AssignServer {
        to: u64,
        server_id: String,
    },
    CallServer {
        id: String,
        method: Method,
    },
    ClientConnected,
    CreateEventTemplate {
        name: String,
    },
    CreateTournament {
        name: String,
    },
    IdentityDisconnected,
    LoadServerConfig {
        id: String,
        with_config: u64,
    },
    OnTournamentEventSchedule {
        arg: TournamentEventSchedule,
    },
    PostEvent {
        id: String,
        event: Event,
    },
    ProvisionMatch {
        to: u64,
        with_config: Option<u64>,
        auto_provisioning_server: bool,
    },
    TryStart {
        match_id: u64,
    },
}

impl __sdk::InModule for Reducer {
    type Module = RemoteModule;
}

impl __sdk::Reducer for Reducer {
    fn reducer_name(&self) -> &'static str {
        match self {
            Reducer::AddEvent { .. } => "add_event",
            Reducer::AddServer { .. } => "add_server",
            Reducer::AddStage { .. } => "add_stage",
            Reducer::AssignServer { .. } => "assign_server",
            Reducer::CallServer { .. } => "call_server",
            Reducer::ClientConnected => "client_connected",
            Reducer::CreateEventTemplate { .. } => "create_event_template",
            Reducer::CreateTournament { .. } => "create_tournament",
            Reducer::IdentityDisconnected => "identity_disconnected",
            Reducer::LoadServerConfig { .. } => "load_server_config",
            Reducer::OnTournamentEventSchedule { .. } => "on_tournament_event_schedule",
            Reducer::PostEvent { .. } => "post_event",
            Reducer::ProvisionMatch { .. } => "provision_match",
            Reducer::TryStart { .. } => "try_start",
        }
    }
}
impl TryFrom<__ws::ReducerCallInfo<__ws::BsatnFormat>> for Reducer {
    type Error = __sdk::Error;
    fn try_from(value: __ws::ReducerCallInfo<__ws::BsatnFormat>) -> __sdk::Result<Self> {
        match &value.reducer_name[..] {
            "add_event" => Ok(
                __sdk::parse_reducer_args::<add_event_reducer::AddEventArgs>(
                    "add_event",
                    &value.args,
                )?
                .into(),
            ),
            "add_server" => Ok(
                __sdk::parse_reducer_args::<add_server_reducer::AddServerArgs>(
                    "add_server",
                    &value.args,
                )?
                .into(),
            ),
            "add_stage" => Ok(
                __sdk::parse_reducer_args::<add_stage_reducer::AddStageArgs>(
                    "add_stage",
                    &value.args,
                )?
                .into(),
            ),
            "assign_server" => Ok(__sdk::parse_reducer_args::<
                assign_server_reducer::AssignServerArgs,
            >("assign_server", &value.args)?
            .into()),
            "call_server" => Ok(
                __sdk::parse_reducer_args::<call_server_reducer::CallServerArgs>(
                    "call_server",
                    &value.args,
                )?
                .into(),
            ),
            "client_connected" => Ok(__sdk::parse_reducer_args::<
                client_connected_reducer::ClientConnectedArgs,
            >("client_connected", &value.args)?
            .into()),
            "create_event_template" => Ok(__sdk::parse_reducer_args::<
                create_event_template_reducer::CreateEventTemplateArgs,
            >("create_event_template", &value.args)?
            .into()),
            "create_tournament" => Ok(__sdk::parse_reducer_args::<
                create_tournament_reducer::CreateTournamentArgs,
            >("create_tournament", &value.args)?
            .into()),
            "identity_disconnected" => Ok(__sdk::parse_reducer_args::<
                identity_disconnected_reducer::IdentityDisconnectedArgs,
            >("identity_disconnected", &value.args)?
            .into()),
            "load_server_config" => Ok(__sdk::parse_reducer_args::<
                load_server_config_reducer::LoadServerConfigArgs,
            >("load_server_config", &value.args)?
            .into()),
            "on_tournament_event_schedule" => {
                Ok(__sdk::parse_reducer_args::<
                    on_tournament_event_schedule_reducer::OnTournamentEventScheduleArgs,
                >("on_tournament_event_schedule", &value.args)?
                .into())
            }
            "post_event" => Ok(
                __sdk::parse_reducer_args::<post_event_reducer::PostEventArgs>(
                    "post_event",
                    &value.args,
                )?
                .into(),
            ),
            "provision_match" => Ok(__sdk::parse_reducer_args::<
                provision_match_reducer::ProvisionMatchArgs,
            >("provision_match", &value.args)?
            .into()),
            "try_start" => Ok(
                __sdk::parse_reducer_args::<try_start_reducer::TryStartArgs>(
                    "try_start",
                    &value.args,
                )?
                .into(),
            ),
            unknown => {
                Err(
                    __sdk::InternalError::unknown_name("reducer", unknown, "ReducerCallInfo")
                        .into(),
                )
            }
        }
    }
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct DbUpdate {
    event_config: __sdk::TableUpdate<EventConfig>,
    event_stage: __sdk::TableUpdate<EventStage>,
    match_template: __sdk::TableUpdate<MatchTemplate>,
    stage_match: __sdk::TableUpdate<StageMatch>,
    stage_template: __sdk::TableUpdate<StageTemplate>,
    tm_server: __sdk::TableUpdate<TmServer>,
    tm_server_config: __sdk::TableUpdate<TmServerConfig>,
    tm_server_event: __sdk::TableUpdate<TmServerEvent>,
    tournament: __sdk::TableUpdate<Tournament>,
    tournament_event: __sdk::TableUpdate<TournamentEvent>,
    tournament_event_schedule: __sdk::TableUpdate<TournamentEventSchedule>,
    user: __sdk::TableUpdate<User>,
}

impl TryFrom<__ws::DatabaseUpdate<__ws::BsatnFormat>> for DbUpdate {
    type Error = __sdk::Error;
    fn try_from(raw: __ws::DatabaseUpdate<__ws::BsatnFormat>) -> Result<Self, Self::Error> {
        let mut db_update = DbUpdate::default();
        for table_update in raw.tables {
            match &table_update.table_name[..] {
                "event_config" => db_update
                    .event_config
                    .append(event_config_table::parse_table_update(table_update)?),
                "event_stage" => db_update
                    .event_stage
                    .append(event_stage_table::parse_table_update(table_update)?),
                "match_template" => db_update
                    .match_template
                    .append(match_template_table::parse_table_update(table_update)?),
                "stage_match" => db_update
                    .stage_match
                    .append(stage_match_table::parse_table_update(table_update)?),
                "stage_template" => db_update
                    .stage_template
                    .append(stage_template_table::parse_table_update(table_update)?),
                "tm_server" => db_update
                    .tm_server
                    .append(tm_server_table::parse_table_update(table_update)?),
                "tm_server_config" => db_update
                    .tm_server_config
                    .append(tm_server_config_table::parse_table_update(table_update)?),
                "tm_server_event" => db_update
                    .tm_server_event
                    .append(tm_server_event_table::parse_table_update(table_update)?),
                "tournament" => db_update
                    .tournament
                    .append(tournament_table::parse_table_update(table_update)?),
                "tournament_event" => db_update
                    .tournament_event
                    .append(tournament_event_table::parse_table_update(table_update)?),
                "tournament_event_schedule" => db_update.tournament_event_schedule.append(
                    tournament_event_schedule_table::parse_table_update(table_update)?,
                ),
                "user" => db_update
                    .user
                    .append(user_table::parse_table_update(table_update)?),

                unknown => {
                    return Err(__sdk::InternalError::unknown_name(
                        "table",
                        unknown,
                        "DatabaseUpdate",
                    )
                    .into());
                }
            }
        }
        Ok(db_update)
    }
}

impl __sdk::InModule for DbUpdate {
    type Module = RemoteModule;
}

impl __sdk::DbUpdate for DbUpdate {
    fn apply_to_client_cache(
        &self,
        cache: &mut __sdk::ClientCache<RemoteModule>,
    ) -> AppliedDiff<'_> {
        let mut diff = AppliedDiff::default();

        diff.event_config = cache
            .apply_diff_to_table::<EventConfig>("event_config", &self.event_config)
            .with_updates_by_pk(|row| &row.id);
        diff.event_stage = cache
            .apply_diff_to_table::<EventStage>("event_stage", &self.event_stage)
            .with_updates_by_pk(|row| &row.id);
        diff.match_template = cache
            .apply_diff_to_table::<MatchTemplate>("match_template", &self.match_template)
            .with_updates_by_pk(|row| &row.id);
        diff.stage_match = cache
            .apply_diff_to_table::<StageMatch>("stage_match", &self.stage_match)
            .with_updates_by_pk(|row| &row.id);
        diff.stage_template =
            cache.apply_diff_to_table::<StageTemplate>("stage_template", &self.stage_template);
        diff.tm_server = cache
            .apply_diff_to_table::<TmServer>("tm_server", &self.tm_server)
            .with_updates_by_pk(|row| &row.id);
        diff.tm_server_config = cache
            .apply_diff_to_table::<TmServerConfig>("tm_server_config", &self.tm_server_config)
            .with_updates_by_pk(|row| &row.id);
        diff.tm_server_event = cache
            .apply_diff_to_table::<TmServerEvent>("tm_server_event", &self.tm_server_event)
            .with_updates_by_pk(|row| &row.id);
        diff.tournament = cache
            .apply_diff_to_table::<Tournament>("tournament", &self.tournament)
            .with_updates_by_pk(|row| &row.id);
        diff.tournament_event = cache
            .apply_diff_to_table::<TournamentEvent>("tournament_event", &self.tournament_event)
            .with_updates_by_pk(|row| &row.id);
        diff.tournament_event_schedule = cache
            .apply_diff_to_table::<TournamentEventSchedule>(
                "tournament_event_schedule",
                &self.tournament_event_schedule,
            )
            .with_updates_by_pk(|row| &row.scheduled_id);
        diff.user = cache
            .apply_diff_to_table::<User>("user", &self.user)
            .with_updates_by_pk(|row| &row.identity);

        diff
    }
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct AppliedDiff<'r> {
    event_config: __sdk::TableAppliedDiff<'r, EventConfig>,
    event_stage: __sdk::TableAppliedDiff<'r, EventStage>,
    match_template: __sdk::TableAppliedDiff<'r, MatchTemplate>,
    stage_match: __sdk::TableAppliedDiff<'r, StageMatch>,
    stage_template: __sdk::TableAppliedDiff<'r, StageTemplate>,
    tm_server: __sdk::TableAppliedDiff<'r, TmServer>,
    tm_server_config: __sdk::TableAppliedDiff<'r, TmServerConfig>,
    tm_server_event: __sdk::TableAppliedDiff<'r, TmServerEvent>,
    tournament: __sdk::TableAppliedDiff<'r, Tournament>,
    tournament_event: __sdk::TableAppliedDiff<'r, TournamentEvent>,
    tournament_event_schedule: __sdk::TableAppliedDiff<'r, TournamentEventSchedule>,
    user: __sdk::TableAppliedDiff<'r, User>,
}

impl __sdk::InModule for AppliedDiff<'_> {
    type Module = RemoteModule;
}

impl<'r> __sdk::AppliedDiff<'r> for AppliedDiff<'r> {
    fn invoke_row_callbacks(
        &self,
        event: &EventContext,
        callbacks: &mut __sdk::DbCallbacks<RemoteModule>,
    ) {
        callbacks.invoke_table_row_callbacks::<EventConfig>(
            "event_config",
            &self.event_config,
            event,
        );
        callbacks.invoke_table_row_callbacks::<EventStage>("event_stage", &self.event_stage, event);
        callbacks.invoke_table_row_callbacks::<MatchTemplate>(
            "match_template",
            &self.match_template,
            event,
        );
        callbacks.invoke_table_row_callbacks::<StageMatch>("stage_match", &self.stage_match, event);
        callbacks.invoke_table_row_callbacks::<StageTemplate>(
            "stage_template",
            &self.stage_template,
            event,
        );
        callbacks.invoke_table_row_callbacks::<TmServer>("tm_server", &self.tm_server, event);
        callbacks.invoke_table_row_callbacks::<TmServerConfig>(
            "tm_server_config",
            &self.tm_server_config,
            event,
        );
        callbacks.invoke_table_row_callbacks::<TmServerEvent>(
            "tm_server_event",
            &self.tm_server_event,
            event,
        );
        callbacks.invoke_table_row_callbacks::<Tournament>("tournament", &self.tournament, event);
        callbacks.invoke_table_row_callbacks::<TournamentEvent>(
            "tournament_event",
            &self.tournament_event,
            event,
        );
        callbacks.invoke_table_row_callbacks::<TournamentEventSchedule>(
            "tournament_event_schedule",
            &self.tournament_event_schedule,
            event,
        );
        callbacks.invoke_table_row_callbacks::<User>("user", &self.user, event);
    }
}

#[doc(hidden)]
pub struct RemoteModule;

impl __sdk::InModule for RemoteModule {
    type Module = Self;
}

/// The `reducers` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
pub struct RemoteReducers {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteReducers {
    type Module = RemoteModule;
}

#[doc(hidden)]
/// The `set_reducer_flags` field of [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
/// Each method sets the flags for the reducer with the same name.
///
/// This type is currently unstable and may be removed without a major version bump.
pub struct SetReducerFlags {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for SetReducerFlags {
    type Module = RemoteModule;
}

/// The `db` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each table defined by the module.
pub struct RemoteTables {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteTables {
    type Module = RemoteModule;
}

/// A connection to a remote module, including a materialized view of a subset of the database.
///
/// Connect to a remote module by calling [`DbConnection::builder`]
/// and using the [`__sdk::DbConnectionBuilder`] builder-pattern constructor.
///
/// You must explicitly advance the connection by calling any one of:
///
/// - [`DbConnection::frame_tick`].
/// - [`DbConnection::run_threaded`].
/// - [`DbConnection::run_async`].
/// - [`DbConnection::advance_one_message`].
/// - [`DbConnection::advance_one_message_blocking`].
/// - [`DbConnection::advance_one_message_async`].
///
/// Which of these methods you should call depends on the specific needs of your application,
/// but you must call one of them, or else the connection will never progress.
pub struct DbConnection {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    #[doc(hidden)]
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,

    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for DbConnection {
    type Module = RemoteModule;
}

impl __sdk::DbContext for DbConnection {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl DbConnection {
    /// Builder-pattern constructor for a connection to a remote module.
    ///
    /// See [`__sdk::DbConnectionBuilder`] for required and optional configuration for the new connection.
    pub fn builder() -> __sdk::DbConnectionBuilder<RemoteModule> {
        __sdk::DbConnectionBuilder::new()
    }

    /// If any WebSocket messages are waiting, process one of them.
    ///
    /// Returns `true` if a message was processed, or `false` if the queue is empty.
    /// Callers should invoke this message in a loop until it returns `false`
    /// or for as much time is available to process messages.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::frame_tick`] each frame
    /// to fully exhaust the queue whenever time is available.
    pub fn advance_one_message(&self) -> __sdk::Result<bool> {
        self.imp.advance_one_message()
    }

    /// Process one WebSocket message, potentially blocking the current thread until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_threaded`] to spawn a thread
    /// which advances the connection automatically.
    pub fn advance_one_message_blocking(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_blocking()
    }

    /// Process one WebSocket message, `await`ing until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_async`] to run an `async` loop
    /// which advances the connection when polled.
    pub async fn advance_one_message_async(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_async().await
    }

    /// Process all WebSocket messages waiting in the queue,
    /// then return without `await`ing or blocking the current thread.
    pub fn frame_tick(&self) -> __sdk::Result<()> {
        self.imp.frame_tick()
    }

    /// Spawn a thread which processes WebSocket messages as they are received.
    pub fn run_threaded(&self) -> std::thread::JoinHandle<()> {
        self.imp.run_threaded()
    }

    /// Run an `async` loop which processes WebSocket messages when polled.
    pub async fn run_async(&self) -> __sdk::Result<()> {
        self.imp.run_async().await
    }
}

impl __sdk::DbConnection for DbConnection {
    fn new(imp: __sdk::DbContextImpl<RemoteModule>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            imp,
        }
    }
}

/// A handle on a subscribed query.
// TODO: Document this better after implementing the new subscription API.
#[derive(Clone)]
pub struct SubscriptionHandle {
    imp: __sdk::SubscriptionHandleImpl<RemoteModule>,
}

impl __sdk::InModule for SubscriptionHandle {
    type Module = RemoteModule;
}

impl __sdk::SubscriptionHandle for SubscriptionHandle {
    fn new(imp: __sdk::SubscriptionHandleImpl<RemoteModule>) -> Self {
        Self { imp }
    }

    /// Returns true if this subscription has been terminated due to an unsubscribe call or an error.
    fn is_ended(&self) -> bool {
        self.imp.is_ended()
    }

    /// Returns true if this subscription has been applied and has not yet been unsubscribed.
    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    /// Unsubscribe from the query controlled by this `SubscriptionHandle`,
    /// then run `on_end` when its rows are removed from the client cache.
    fn unsubscribe_then(self, on_end: __sdk::OnEndedCallback<RemoteModule>) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(Some(on_end))
    }

    fn unsubscribe(self) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(None)
    }
}

/// Alias trait for a [`__sdk::DbContext`] connected to this module,
/// with that trait's associated types bounded to this module's concrete types.
///
/// Users can use this trait as a boundary on definitions which should accept
/// either a [`DbConnection`] or an [`EventContext`] and operate on either.
pub trait RemoteDbContext:
    __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SetReducerFlags = SetReducerFlags,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
>
{
}
impl<
        Ctx: __sdk::DbContext<
            DbView = RemoteTables,
            Reducers = RemoteReducers,
            SetReducerFlags = SetReducerFlags,
            SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
        >,
    > RemoteDbContext for Ctx
{
}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::Event`],
/// passed to [`__sdk::Table::on_insert`], [`__sdk::Table::on_delete`] and [`__sdk::TableWithPrimaryKey::on_update`] callbacks.
pub struct EventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: __sdk::Event<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for EventContext {
    type Event = __sdk::Event<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for EventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for EventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::EventContext for EventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::ReducerEvent`],
/// passed to on-reducer callbacks.
pub struct ReducerEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: __sdk::ReducerEvent<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ReducerEventContext {
    type Event = __sdk::ReducerEvent<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ReducerEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ReducerEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::ReducerEventContext for ReducerEventContext {}

/// An [`__sdk::DbContext`] passed to [`__sdk::SubscriptionBuilder::on_applied`] and [`SubscriptionHandle::unsubscribe_then`] callbacks.
pub struct SubscriptionEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for SubscriptionEventContext {
    type Event = ();
    fn event(&self) -> &Self::Event {
        &()
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, _event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            imp,
        }
    }
}

impl __sdk::InModule for SubscriptionEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for SubscriptionEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::SubscriptionEventContext for SubscriptionEventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::Error`],
/// passed to [`__sdk::DbConnectionBuilder::on_disconnect`], [`__sdk::DbConnectionBuilder::on_connect_error`] and [`__sdk::SubscriptionBuilder::on_error`] callbacks.
pub struct ErrorContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: Option<__sdk::Error>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ErrorContext {
    type Event = Option<__sdk::Error>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ErrorContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ErrorContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::ErrorContext for ErrorContext {}

impl __sdk::SpacetimeModule for RemoteModule {
    type DbConnection = DbConnection;
    type EventContext = EventContext;
    type ReducerEventContext = ReducerEventContext;
    type SubscriptionEventContext = SubscriptionEventContext;
    type ErrorContext = ErrorContext;
    type Reducer = Reducer;
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;
    type DbUpdate = DbUpdate;
    type AppliedDiff<'r> = AppliedDiff<'r>;
    type SubscriptionHandle = SubscriptionHandle;

    fn register_tables(client_cache: &mut __sdk::ClientCache<Self>) {
        event_config_table::register_table(client_cache);
        event_stage_table::register_table(client_cache);
        match_template_table::register_table(client_cache);
        stage_match_table::register_table(client_cache);
        stage_template_table::register_table(client_cache);
        tm_server_table::register_table(client_cache);
        tm_server_config_table::register_table(client_cache);
        tm_server_event_table::register_table(client_cache);
        tournament_table::register_table(client_cache);
        tournament_event_table::register_table(client_cache);
        tournament_event_schedule_table::register_table(client_cache);
        user_table::register_table(client_cache);
    }
}
